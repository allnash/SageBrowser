import glob
import os
import re

from PyQt6.QtCore import pyqtSignal, Qt, QTimer
from PyQt6.QtWidgets import QVBoxLayout, QWidget, QScrollArea, QHBoxLayout, QPushButton

from browser.widgets.chat_input import ChatInput
from browser.widgets.chat_message import ChatMessage
from lib.models import Role


def import_traceback():
    import traceback
    return traceback.format_exc()

class ChatWindow(QWidget):
    message_sent = pyqtSignal(str)
    browser_command = pyqtSignal(str, dict)  # Signal for browser commands

    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_response = None
        self.command_prefix = "/"  # Define command prefix
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Chat history area
        self.chat_area = QWidget()
        self.chat_layout = QVBoxLayout(self.chat_area)
        self.chat_layout.addStretch()

        # Scroll area for chat
        scroll = QScrollArea()
        scroll.setWidget(self.chat_area)
        scroll.setWidgetResizable(True)
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)

        # Input area
        input_layout = QHBoxLayout()
        self.message_input = ChatInput(self)  # Using custom ChatInput
        send_button = QPushButton("Send")
        send_button.clicked.connect(self.send_message)

        input_layout.addWidget(self.message_input)
        input_layout.addWidget(send_button)

        layout.addWidget(scroll)
        layout.addLayout(input_layout)

    def send_message(self, message=None, from_program=False):
        """Send a message, optionally from program rather than user input"""
        if message is None:
            # If no message provided, get from the input field
            message = self.message_input.toPlainText().strip()

        if not message:
            return

        # If not from program, clear the input field
        if not from_program:
            self.message_input.clear()

        # Check if message is a command
        if message.startswith(self.command_prefix):
            self.add_message(message, True)  # Show command in chat
            self.handle_browser_command(message)
        else:
            self.add_message(message, True)
            self.message_sent.emit(message)

        self.current_response = None

    def handle_browser_command(self, command_text):
        """Handle browser control commands"""
        # Strip prefix and split into command and arguments
        parts = command_text[len(self.command_prefix):].strip().split(" ", 1)
        command = parts[0].lower()
        args = parts[1] if len(parts) > 1 else ""

        # Command dictionary - maps commands to handlers
        commands = {
            "goto": self.cmd_goto,
            "back": self.cmd_back,
            "forward": self.cmd_forward,
            "reload": self.cmd_reload,
            "autofill": self.cmd_auto_fill,
            "mapfields": self.cmd_map_fields,
            "automap": self.cmd_auto_map,
            "fillform": self.cmd_fill_form,
            "search": self.cmd_search_pages,
            "open": self.cmd_open_result,
            "show": self.cmd_show_content,
            "click": self.cmd_click,
            "type": self.cmd_type,
            "submit": self.cmd_submit,
            "help": self.cmd_help,
            "debug": self.cmd_debug,
            # Form element commands
            "select": self.cmd_select,
            "radio": self.cmd_radio,
            "checkbox": self.cmd_checkbox,
            "custom": self.cmd_custom,
        }

        if command in commands:
            commands[command](args)
        else:
            self.add_message(f"Unknown command: {command}. Type /help for available commands.", False)

    def cmd_goto(self, args):
        """Navigate to URL"""
        if not args:
            self.add_message("Usage: /goto [url]", False)
            return
        self.browser_command.emit("goto", {"url": args})
        self.add_message(f"Navigating to {args}...", False)

    def cmd_back(self, args):
        """Go back in history"""
        self.browser_command.emit("back", {})
        self.add_message("Going back...", False)

    def cmd_forward(self, args):
        """Go forward in history"""
        self.browser_command.emit("forward", {})
        self.add_message("Going forward...", False)

    def cmd_reload(self, args):
        """Reload page"""
        self.browser_command.emit("reload", {})
        self.add_message("Reloading page...", False)

    def cmd_detect_form(self, args):
        """Detect form fields on the current page"""
        self.browser_command.emit("detect_form", {})
        self.add_message("Detecting form fields on current page...", False)

    def cmd_auto_fill(self, args):
        """Auto-fill the form with sample data generated by LLM"""
        self.browser_command.emit("auto_fill", {})
        self.add_message("Auto-filling form with sample data...", False)

    def cmd_map_fields(self, args):
        """Map form fields with detailed information"""
        self.browser_command.emit("map_fields", {})
        self.add_message("Mapping form fields with detailed information...", False)

    def cmd_auto_map(self, args):
        """Map fields and generate appropriate data automatically"""
        self.browser_command.emit("auto_map", {})
        self.add_message("Automatically mapping fields and generating form data...", False)

    def cmd_fill_form(self, args):
        """Fill a form with provided data"""
        if not args:
            self.add_message("Usage: /fillform [JSON data or field=value pairs]", False)
            return

        try:
            # Try to parse as JSON
            import json
            form_data = json.loads(args)
        except json.JSONDecodeError:
            # Parse as field=value pairs
            form_data = {}
            pairs = args.split(",")
            for pair in pairs:
                if "=" in pair:
                    key, value = pair.split("=", 1)
                    form_data[key.strip()] = value.strip()

        if not form_data:
            self.add_message("No valid form data provided", False)
            return

        self.browser_command.emit("fillform", {"data": form_data})
        self.add_message(f"Filling form with data: {form_data}", False)

    def cmd_click(self, args):
        """Click on an element by selector"""
        if not args:
            self.add_message("Usage: /click [CSS selector or element text]", False)
            return
        self.browser_command.emit("click", {"selector": args})
        self.add_message(f"Clicking on element: {args}", False)

    def cmd_type(self, args):
        """Type into an input field"""
        # Improved parsing for fields with spaces
        # Support for both syntax: /type "Full Name" Nash and /type Full Name:Nash

        if ":" in args:
            # Format: Field:Value
            parts = args.split(":", 1)
            if len(parts) < 2:
                self.add_message("Usage: /type [field]:[text] or /type \"[field]\" [text]", False)
                return
            selector, text = parts[0].strip(), parts[1].strip()
        elif '"' in args:
            # Format: "Field" Value
            import re
            match = re.match(r'"([^"]+)"\s+(.*)', args)
            if not match:
                self.add_message('Usage: /type [field]:[text] or /type "[field]" [text]', False)
                return
            selector, text = match.group(1), match.group(2)
        else:
            # Simple fallback - no hardcoded field names
            # Just use first word as selector and the rest as text
            # This is unreliable but provides backward compatibility
            parts = args.split(" ")
            if len(parts) < 2:
                self.add_message('Usage: /type [field]:[text] or /type "[field]" [text]', False)
                return

            # Fallback to simple splitting
            selector, text = parts[0], " ".join(parts[1:])

        self.browser_command.emit("type", {"selector": selector, "text": text})
        self.add_message(f"Typing '{text}' into '{selector}'", False)

    def cmd_select(self, args):
        """Select an option from a dropdown"""
        if not args or ":" not in args:
            self.add_message("Usage: /select [selector]:[option]", False)
            return

        parts = args.split(":", 1)
        selector = parts[0].strip()
        option = parts[1].strip()

        if not selector or not option:
            self.add_message("Both selector and option value are required", False)
            return

        self.browser_command.emit("select", {"selector": selector, "value": option})
        self.add_message(f"Selecting option '{option}' from '{selector}'", False)

    def cmd_radio(self, args):
        """Select a radio button"""
        if not args:
            self.add_message("Usage: /radio [selector] or /radio [selector]:[value]", False)
            return

        if ":" in args:
            parts = args.split(":", 1)
            selector = parts[0].strip()
            value = parts[1].strip()
        else:
            selector = args.strip()
            value = None

        if not selector:
            self.add_message("Selector is required", False)
            return

        self.browser_command.emit("radio", {"selector": selector, "value": value})
        if value:
            self.add_message(f"Selecting radio button '{selector}' with value '{value}'", False)
        else:
            self.add_message(f"Selecting radio button '{selector}'", False)

    def cmd_checkbox(self, args):
        """Check or uncheck a checkbox"""
        if not args:
            self.add_message("Usage: /checkbox [selector] or /checkbox [selector]:[true/false]", False)
            return

        if ":" in args:
            parts = args.split(":", 1)
            selector = parts[0].strip()
            value_str = parts[1].strip().lower()
            check = value_str in ("true", "yes", "1", "on")
        else:
            selector = args.strip()
            check = True  # Default to checking

        if not selector:
            self.add_message("Selector is required", False)
            return

        self.browser_command.emit("checkbox", {"selector": selector, "check": check})
        action = "Checking" if check else "Unchecking"
        self.add_message(f"{action} checkbox '{selector}'", False)

    def cmd_custom(self, args):
        """Click a custom element"""
        if not args:
            self.add_message("Usage: /custom [selector] or /custom [selector]:[attribute]:[value]", False)
            return

        parts = args.split(":")

        if len(parts) == 1:
            selector = parts[0].strip()
            attribute = None
            value = None
        elif len(parts) == 2:
            selector = parts[0].strip()
            value = parts[1].strip()
            attribute = None
        elif len(parts) >= 3:
            selector = parts[0].strip()
            attribute = parts[1].strip()
            value = parts[2].strip()

        if not selector:
            self.add_message("Selector is required", False)
            return

        self.browser_command.emit("custom", {"selector": selector, "attribute": attribute, "value": value})

        message = f"Clicking custom element '{selector}'"
        if attribute and value:
            message += f" with {attribute}='{value}'"
        elif value:
            message += f" with value='{value}'"

        self.add_message(message, False)

    def cmd_submit(self, args):
        """Submit a form"""
        selector = args if args else "form"
        self.browser_command.emit("submit", {"selector": selector})
        self.add_message(f"Submitting form: {selector}", False)


    from typing import List, Dict, Any

    def cmd_search_pages(self, args):
        """Search through saved pages with vector search (falls back to keyword search)"""
        if not args:
            self.add_message("Usage: /search [search query]", Role.WEB_BROWSER)
            return

        query = args.strip()
        self.add_message(f"Searching saved pages for: {query}", Role.WEB_BROWSER)

        # Check if saved_pages directory exists and has files
        saved_pages_dir = "saved_pages"
        if not os.path.exists(saved_pages_dir):
            os.makedirs(saved_pages_dir)
            self.add_message("No saved pages found. Try browsing and analyzing some pages first.", Role.WEB_BROWSER)
            return

        # Check if directory has any .md files
        if not glob.glob(os.path.join(saved_pages_dir, "*.md")):
            self.add_message("No saved pages found. Try browsing and analyzing some pages first.", Role.WEB_BROWSER)
            return

        # Try vector search first, then fall back to keyword search
        results = []
        search_method = "vector"

        try:
            # Try to import vector search
            self.add_message("Attempting vector search...", Role.WEB_BROWSER)

            # Add lib directory to path if not already there
            import sys
            lib_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'lib')
            if lib_path not in sys.path:
                sys.path.append(lib_path)

            # Try to import vector_search module
            try:
                from lib.vector_search import search_saved_pages as vector_search
                # Perform vector search
                results = vector_search(query, top_k=5)
                if results:
                    self.add_message("Vector search successful.", Role.WEB_BROWSER)
            except ImportError as e:
                self.add_message(f"Vector search not available: {str(e)}", Role.WEB_BROWSER)
                self.add_message("Falling back to keyword search...", Role.WEB_BROWSER)
                search_method = "keyword"
            except Exception as e:
                self.add_message(f"Vector search failed: {str(e)}", Role.WEB_BROWSER)
                self.add_message("Falling back to keyword search...", Role.WEB_BROWSER)
                search_method = "keyword"
        except Exception as e:
            self.add_message(f"Error during vector search: {str(e)}", Role.WEB_BROWSER)
            self.add_message("Falling back to keyword search...", Role.WEB_BROWSER)
            search_method = "keyword"

        # If vector search failed or returned no results, try keyword search
        if search_method == "keyword" or not results:
            try:
                # Use the embedded keyword search implementation
                results = self._keyword_search(query, top_k=5)
                if results:
                    self.add_message("Keyword search successful.", Role.WEB_BROWSER)
            except Exception as e:
                self.add_message(f"Keyword search failed: {str(e)}", Role.WEB_BROWSER)

        # Check if we have any results
        if not results:
            self.add_message("No matching pages found for your query.", Role.WEB_BROWSER)
            return

        # Format and display results
        result_text = "🔍 Search Results:\n\n"

        for i, result in enumerate(results, 1):
            metadata = result.get("metadata", {})
            title = metadata.get("title", "Untitled")
            url = metadata.get("url", "")
            similarity = result.get("similarity", 0) * 100  # Convert to percentage

            result_text += f"**{i}. {title}** ({similarity:.1f}% match)\n"
            result_text += f"Source: {url}\n"

            # Show a snippet of the matching chunk
            chunk = result.get("chunk", "")
            if chunk:
                # Truncate and clean up the snippet
                max_snippet_length = 200
                snippet = chunk[:max_snippet_length]
                if len(chunk) > max_snippet_length:
                    snippet += "..."
                result_text += f"Snippet: {snippet}\n"

            result_text += "\n"

        # Add command hints
        result_text += "Use `/open [number]` to open a result in the browser or `/show [number]` to display its full content."

        self.add_message(result_text, Role.WEB_BROWSER)

        # Store results for later reference
        self.last_search_results = results

    def _keyword_search(self, query: str, top_k: int = 5) -> List[Dict[str, Any]]:
        """Simple keyword-based search for saved pages"""
        save_dir = "saved_pages"
        md_files = glob.glob(os.path.join(save_dir, "*.md"))

        # Normalize query
        query_terms = self._normalize_text(query).split()
        results = []

        # Search through files
        for file_path in md_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Get metadata and content
                metadata = self._extract_metadata(content)
                text_content = self._remove_frontmatter(content)

                # Normalize content
                normalized_content = self._normalize_text(text_content)
                normalized_title = self._normalize_text(metadata.get("title", ""))

                # Calculate simple relevance score
                score = 0
                best_snippet = ""

                # Check title match (higher weight)
                for term in query_terms:
                    if term in normalized_title:
                        score += 5  # Title matches are more important

                # Check content matches
                matching_snippets = []
                paragraphs = re.split(r'\n\n+', text_content)

                for paragraph in paragraphs:
                    norm_para = self._normalize_text(paragraph)
                    para_score = 0

                    for term in query_terms:
                        if term in norm_para:
                            para_score += 1

                    if para_score > 0:
                        matching_snippets.append((para_score, paragraph))

                # Sort snippets by score
                matching_snippets.sort(reverse=True, key=lambda x: x[0])

                # Get best snippet
                if matching_snippets:
                    score += matching_snippets[0][0]
                    best_snippet = matching_snippets[0][1]

                    # Truncate snippet if needed
                    if len(best_snippet) > 200:
                        best_snippet = best_snippet[:200] + "..."

                # Only include results with matches
                if score > 0:
                    results.append({
                        "filename": os.path.basename(file_path),
                        "metadata": metadata,
                        "chunk": best_snippet,
                        "similarity": score / (len(query_terms) * 6),  # Normalize to 0-1
                        "file_path": file_path
                    })

            except Exception as e:
                print(f"Error processing file {file_path}: {str(e)}")

        # Sort by score (highest first)
        results.sort(key=lambda x: x["similarity"], reverse=True)

        # Return top k results
        return results[:top_k]

    def _normalize_text(self, text: str) -> str:
        """Normalize text for keyword search"""
        if not text:
            return ""
        # Convert to lowercase
        text = text.lower()
        # Replace multiple spaces with single space
        text = re.sub(r'\s+', ' ', text)
        # Remove punctuation that might interfere with matching
        text = re.sub(r'[^\w\s]', ' ', text)
        return text.strip()

    def _extract_metadata(self, content: str) -> Dict[str, Any]:
        """Extract metadata from markdown front matter"""
        metadata = {}

        # Extract front matter
        match = re.match(r'---\n(.*?)\n---\n', content, re.DOTALL)
        if match:
            front_matter = match.group(1)
            for line in front_matter.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    metadata[key.strip()] = value.strip().strip('"\'')

        return metadata

    def _remove_frontmatter(self, content: str) -> str:
        """Remove front matter from markdown content"""
        return re.sub(r'---\n.*?\n---\n', '', content, flags=re.DOTALL).strip()

    def cmd_open_result(self, args):
        """Open a search result in the browser"""
        if not args:
            self.add_message("Usage: /open [result number]", False)
            return

        try:
            # Get result number
            result_num = int(args.strip())

            # Check if we have search results
            if not hasattr(self, 'last_search_results') or not self.last_search_results:
                self.add_message("No search results available. Please run a search first.", False)
                return

            # Validate result number
            if result_num < 1 or result_num > len(self.last_search_results):
                self.add_message(f"Invalid result number. Please choose 1-{len(self.last_search_results)}.", False)
                return

            # Get the selected result
            result = self.last_search_results[result_num - 1]
            url = result.get("metadata", {}).get("url", "")

            if not url:
                self.add_message("URL not found for this result.", False)
                return

            # Navigate to the URL
            self.browser_command.emit("goto", {"url": url})
            self.add_message(f"Opening: {url}", False)

        except ValueError:
            self.add_message("Please specify a valid result number.", False)
        except Exception as e:
            self.add_message(f"Error opening result: {str(e)}", False)

    def cmd_show_content(self, args):
        """Show the full content of a search result"""
        if not args:
            self.add_message("Usage: /show [result number]", False)
            return

        try:
            # Get result number
            result_num = int(args.strip())

            # Check if we have search results
            if not hasattr(self, 'last_search_results') or not self.last_search_results:
                self.add_message("No search results available. Please run a search first.", False)
                return

            # Validate result number
            if result_num < 1 or result_num > len(self.last_search_results):
                self.add_message(f"Invalid result number. Please choose 1-{len(self.last_search_results)}.", False)
                return

            # Get the selected result
            result = self.last_search_results[result_num - 1]
            file_path = result.get("file_path", "")

            if not file_path or not os.path.exists(file_path):
                self.add_message("Content file not found for this result.", False)
                return

            # Read the file content
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Extract metadata
            import re
            metadata = {}
            match = re.match(r'---\n(.*?)\n---\n', content, re.DOTALL)
            if match:
                front_matter = match.group(1)
                for line in front_matter.split('\n'):
                    if ':' in line:
                        key, value = line.split(':', 1)
                        metadata[key.strip()] = value.strip().strip('"\'')

            # Remove front matter from display
            content = re.sub(r'---\n.*?\n---\n', '', content, flags=re.DOTALL)

            # Format the display
            title = metadata.get("title", "Untitled")
            url = metadata.get("url", "")
            date_saved = metadata.get("date_saved", "Unknown date")

            display_text = f"# {title}\n\n"
            display_text += f"Source: {url}\n"
            display_text += f"Saved: {date_saved}\n\n"
            display_text += "---\n\n"
            display_text += content

            self.add_message(display_text, False)

        except ValueError:
            self.add_message("Please specify a valid result number.", False)
        except Exception as e:
            self.add_message(f"Error showing content: {str(e)}", False)

    def cmd_help(self, args):
        """Show help for commands"""
        help_text = """
    Available browser commands:
    /goto [url] - Navigate to URL
    /back - Go back in history
    /forward - Go forward in history
    /reload - Reload current page

    Form commands:
    /fillform [data] - Auto-detect fields and fill form (JSON or field=value,field2=value2)
    /type [field]:[text] - Type text into field (use colon to separate)
    /type "[field]" [text] - Type text into field (use quotes for fields with spaces)
    /click [text] - Click on element with text or button
    /submit - Submit a form
    /debug [selector] - Debug element properties

    Vector search commands:
    /search [query] - Search through saved pages
    /open [number] - Open a search result in the browser
    /show [number] - Display full content of a search result

    Form element commands:
    /select [selector]:[option] - Select an option from a dropdown 
    /radio [name]:[value] - Select a radio button with specified value
    /checkbox [selector]:[true/false] - Check or uncheck a checkbox
    /custom [selector]:[attribute]:[value] - Click a custom element like star ratings

    /help - Show this help
    """
        self.add_message(help_text, False)

    def cmd_debug(self, args):
        """Debug an element's properties"""
        if not args:
            self.add_message("Usage: /debug [CSS selector]", False)
            return

        self.browser_command.emit("debug", {"selector": args})
        self.add_message(f"Debugging element: {args}", False)

    def add_message(self, message: str, is_user: bool = True):
        """Add a message to the chat window

        Args:
            message: The message text to add
            is_user: True if this is a user message, False for assistant/system messages
                     Can also be a Role enum value
        """
        if isinstance(is_user, bool):
            # For user messages, always create a new message widget
            if is_user:
                message_widget = ChatMessage(message, True)
                self.chat_layout.addWidget(message_widget)
                self.current_response = None
            else:
                # For assistant messages
                if self.current_response is None:
                    # Create new message widget for first assistant response
                    self.current_response = ChatMessage(message, False)
                    self.chat_layout.addWidget(self.current_response)
                else:
                    # Update existing message content
                    current_text = self.current_response.content.text()
                    self.current_response.content.setText(current_text + message)
        else:
            # Handle Role enum case (maintaining backward compatibility)
            # Treat any non-user role as an assistant message
            role_is_user = (is_user == Role.USER)

            if role_is_user:
                message_widget = ChatMessage(message, True)
                self.chat_layout.addWidget(message_widget)
                self.current_response = None
            else:
                # For non-user roles (ASSISTANT, SYSTEM, WEB_BROWSER)
                if self.current_response is None:
                    # Create new message widget
                    header_text = "Assistant"
                    if is_user == Role.WEB_BROWSER:
                        header_text = "Browser"
                    elif is_user == Role.SYSTEM:
                        header_text = "System"

                    # Create the message with appropriate styling
                    message_widget = ChatMessage(message, False)
                    if hasattr(message_widget, 'header'):
                        message_widget.header.setText(header_text)
                    self.chat_layout.addWidget(message_widget)
                    self.current_response = message_widget
                else:
                    # Update existing message content
                    current_text = self.current_response.content.text()
                    self.current_response.content.setText(current_text + message)

        # Force scroll to bottom
        QTimer.singleShot(0, lambda: self.scroll_to_bottom())

    def scroll_to_bottom(self):
        scroll = self.findChild(QScrollArea)
        if scroll:
            scroll.verticalScrollBar().setValue(scroll.verticalScrollBar().maximum())